<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[白话文解说java的几种常用设计模式]]></title>
    <url>%2F2019%2F03%2F14%2Fjava-design-pattern%2F</url>
    <content type="text"><![CDATA[今天听到了一个高大上的东西：自由变体。我也不知道是啥，搜都搜不到。反正大神说是几种设计模式混合起来然后自己在包装一下。想象自己好久没复习设计模式了，还是复习一下设计模式。 我们大家都知道JAVA大概有20多种设计模式，这里我估计我复习不完，只能捡常用的了。 创建型模式工厂模式这个模式不多说了，用的第二多了吧，在spring的代码中最明显的beanFactory。说理论的不好理解，我说个通俗的理解。 假设我们准备开了一个奶制品的工厂，我们预计了要生产【纯牛奶】、【酸奶】、【奶酪】。所以我们在找厂房的时候，就找一个大个的厂房，在里面安装上生产3种产品的设备。这样我们厂房就建好了，接下来就是采购商需要啥，我们就给他生产啥，因为我们全都有。就类似下面这样12345678910111213141516171819202122232425262728293031323334353637383940// 奶制品interface Dairy&#123;&#125;// 纯牛奶class Milk implements Dairy&#123;&#125;// 酸奶class Yogurt implements Dairy&#123;&#125;// 奶酪class Cheese implements Dairy&#123;&#125;// 我们的工厂class MyFactory&#123; // 提供商品 public static Dairy get(String name)&#123; Dairy dairy; switch(name)&#123; case "Milk": dairy = new Milk(); break; case "Yogurt": dairy = new Yogurt(); break; case "Cheese": dairy = new Cheese(); break; default: System.err.println("我们不生产这个东西！"); break; &#125; return null; &#125;&#125;// 采购商，他的直接对象只有工厂。class Purchaser&#123; // 获取纯牛奶 Dairy dairy = MyFactory.get("Milk") // 获取酸奶 Dairy dairy = MyFactory.get("Yogurt")&#125; 采购商根本不关注我是怎么生产的，他只需要告诉我们工厂，我需要牛奶或是酸奶。 抽象工厂模式通过我们对工厂模式的了解，我们知道工厂模式在前期的投入非常大，即我们需要同时采购【纯牛奶】、【酸奶】、【奶酪】这3条生产线，那对我们这种穷逼来说压力太大了，有没有什么办法可以减轻这个压力呢？那就是抽象工厂模式。 假设我们目前只有买【纯牛奶】生产线的钱，但是我们又想做【酸奶】、【奶酪】怎么办呢？哈！聪明的你可能想到了，我们可以先开一间生产【纯牛奶】厂，等挣到大钱了再开生产【酸奶】、【奶酪】的厂，就像下面这样：12345// 奶制品工厂interface DairyFactory&#123; Dairy get();&#125; 现在穷，只有先开【纯牛奶】厂了。123456789101112131415161718192021222324class MilkFactory implements DairyFactory&#123; @Override Dairy get()&#123; return new Milk(); &#125;&#125;// 抽象的工厂class AbstractFactory &#123; // 提供商品，太穷了，暂时只提供纯牛奶 public static Dairy get(String name)&#123; Dairy dairy; switch(name)&#123; case "Milk": dairy = new MilkFactory().get(); break; default: System.err.println("我们不生产这个东西！"); break; &#125; return null; &#125;&#125; 哈哈哈，劳资挣大钱了，再开两个厂1234567891011121314151617181920212223242526272829303132333435363738// 新开的酸奶厂class YogurtFactory implements DairyFactory&#123; @Override Dairy get()&#123; return new Yogurt(); &#125;&#125;// 新开的奶酪厂class CheeseFactory implements DairyFactory&#123; @Override Dairy get()&#123; return new Cheese(); &#125;&#125;// 抽象的工厂class AbstractFactory &#123; // 提供商品，现在可以提供酸奶和奶酪了 public static Dairy get(String name)&#123; Dairy dairy; switch(name)&#123; case "Milk": dairy = new MilkFactory().get(); break; case "Yogurt": dairy = new YogurtFactory().get(); break; case "Cheese": dairy = new CheeseFactory().get(); break; default: System.err.println("我们不生产这个东西！"); break; &#125; return null; &#125;&#125; 单例模式顾名思义啊，就是只有一个（就是单身的意思）。 通过以上工厂模式的代码我们发现，每次有采购商来采购都会开一个新的工厂(new DairyFactory())，那肯定不行啊，那哪有那么多钱。所以我们要精益求精（穷），开一个厂服务所有人。就像下面这样：12345678910111213141516171819202122232425262728293031323334353637 class MilkFactory implements DairyFactory&#123; // 不允许在外面建厂了 private MilkFactory()&#123;&#125;; // 就建一个工厂 private static MilkFactory milkFactory = new MilkFactory(); // 得到工厂 public static MilkFactory getFactory()&#123; return milkFactory; &#125; @Override Dairy get()&#123; return new Milk(); &#125;&#125;// 抽象的工厂class AbstractFactory &#123; // 提供商品 public static Dairy get(String name)&#123; Dairy dairy; switch(name)&#123; case "Milk": // 每次都从同一个厂取货 dairy = MilkFactory.getFactory().get(); break; default: System.err.println("我们不生产这个东西！"); break; &#125; return null; &#125;&#125; 注意此处使用了饿汉模式（我建了厂就一定有人来买，就是这么自信），至于懒汉模式(我也不知道有没有人要来买，有人买的时候再建厂吧。)请自行查阅。 建造者模式我们不是搞了个【纯牛奶】厂么，大家知道纯牛奶是有包装盒的，那我们在生产一个包装盒的时候一定要等待牛奶先制好么，那肯定不行，那效率多低啊是吧。所以我们就可以先造盒子，就像下面这种： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 盒装牛奶class Milk implements Dairy&#123; // 包装盒 private String pkg; // 吸管 private String straw; // 牛奶 private String milk; public Milk(MilkBuilder builder)&#123; this.pkg = builder.getPkg(); this.straw = builder.getStraw(); this.milk = builder.getMilk(); &#125;&#125;// 盒装牛奶组装线public MilkBuilder&#123; // 包装盒 private String pkg; // 吸管 private String straw; // 牛奶 private String milk; public MilkBuilder setPkg(String pkg)&#123; this.pkg = pkg return this; &#125; public MilkBuilder setStraw(String straw)&#123; this.straw = straw return this; &#125; public MilkBuilder setMilk(String milk)&#123; this.milk = milk return this; &#125; public String getPkg()&#123;return pkg&#125;; public String getStraw()&#123;return straw&#125;; public String getMilk()&#123;return milk&#125;; // 构建 牛奶 public Milk build()&#123; return new Milk(this); &#125;&#125;// 牛奶工厂class MilkFactory()&#123; Dairy get()&#123; // 只有包装盒 Milk milk = new MilkBuilder().setPkg("全新包装").build(); // 有包装和吸管 Milk milk = new MilkBuilder().setPkg("全新包装").setStraw("全新吸管").build(); return milk; &#125;&#125; 不知道大家发现没有，其实就是个链式操作，不用建造者模式一样能达成，比如下面这样1234567891011121314151617181920212223242526272829303132333435363738394041// 盒装牛奶 class Milk implements Dairy&#123; // 包装盒 private String pkg; // 吸管 private String straw; // 牛奶 private String milk; public Milk()&#123; &#125; public Milk setPkg(String pkg)&#123; this.pkg = pkg return this; &#125; public Milk setStraw(String straw)&#123; this.straw = straw return this; &#125; public Milk setMilk(String milk)&#123; this.milk = milk return this; &#125; &#125; // 牛奶工厂 class MilkFactory()&#123; Dairy get()&#123; // 只有包装盒 Milk milk = new Milk().setPkg("全新包装"); // 有包装和吸管 Milk milk = new Milk().setPkg("全新包装").setStraw("全新吸管"); return milk; &#125; &#125; 是不是感觉差不多拉，哈哈哈。 原型模式其实就是克隆一个出来。就像我们牛奶厂的包装盒，每一个版本都有一个模板，后面生产的所有包装盒，都是根据这个模板来的，只是打印上去的生产日期不一样。如下：12345678910111213141516171819202122232425262728293031323334353637// 初版包装盒class MilkBox implements Cloneable&#123; Date createDate; public Date getCreateDate() &#123; return createDate; &#125; public void setCreateDate(Date createDate) &#123; this.createDate = createDate; &#125; @Override protected Object clone() &#123; try &#123; return super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125;finally &#123; return null; &#125; &#125;&#125;// 工厂class MilkFactory()&#123; Dairy get()&#123; MilkBox temp = new MilkBox(); // 都是使用模板生产 MilkBox box1 = (MilkBox)temp.clone(); MilkBox box2 = (MilkBox)temp.clone(); // box1 先生产，不同的生产日期 box1.setCreateDate(date1); box2.setCreateDate(date2); &#125;&#125; 结构型模式适配器模式适配器模式就是在原来的类上提供新的功能。假设我们现在需要生产【奶糖】,那我们有几种做法呢？无法以下几种： 扩建厂房，增加生产线 增加新的厂房，原材料从老厂房拿 增加新的厂房，原材料自己购买 从上到下依次对应我们的： 类适配 对象适配 接口适配 以下是【奶糖】的定义 1234567891011121314// 高钙奶class Toffee implements Dairy &#123; // 可通过纯牛奶制作 public Toffee(Milk milk)&#123; &#125;&#125;// 高钙奶生产线定义interface ToffeeLine&#123; Toffee getToffee();&#125; 类适配扩大厂房规模，增加生产线1234567891011// 扩大规模后的工厂class BigFactory extends MilkFactory implements ToffeeLine&#123; // 拥有新的生产线，用于生产高钙奶，同时也能生产纯牛奶 @Override Toffee getToffee()&#123; // get()即获取纯牛奶 return new Toffee(get()); &#125;&#125; 对象适配开新厂，原材料从老厂拿12345678910111213// 新创建的工厂class ToffeeFactory implements ToffeeLine&#123; private MilkFactory milkFactory; // 拥有新的生产线，用于生产高钙奶 @Override Toffee getToffee()&#123; // 从牛奶厂获取牛奶 Milk milk = milkFactory.get(); return new Toffee(milk); &#125;&#125; 接口适配这个和上面不一样，这个不容易解释。这么说吧，就是我开一个新厂，我只想让你知道我这个厂是生产【奶糖】的。12345678910111213141516171819202122// 注册一个皮包公司，说自己是乳制品公司，其实要生产汽车abstract class AbstractFactory implements DairyFactory &#123; // 生产乳制品 @Override Dairy get()&#123; // 虽然母公司能生产乳制品，但是我们厂不生产，但是我们又要挂母公司的名头（参考蚂蚁金融和阿里巴巴） &#125; // 生产奶糖 Toffee getToffee();&#125;// 注册新厂房class ToffeeFactory extends AbstractFactory&#123; // 生产奶糖 @Override Toffee getToffee()&#123; &#125;&#125; 这个大家想象一下雅马哈，他啥都能做，做摩托车，做钢琴，做家具。。但是你肯定不能在雅马哈摩托车厂买到雅马哈家具。 装饰模式其实就是增加功能，假设我们要给牛奶厂增加质量检测环节，那质量检测部肯定不需要知道你纯牛奶是如何生产出来的，所以就有一下操作：123456789101112131415161718192021class MilkFactoryDecorator implements DairyFactory&#123; // 注意此处是传进入的 private DairyFactory dairyFactory; public boolean testing()&#123; System.out.println("质量检测"); return true; &#125; @Override Dairy get()&#123; Dairy d = dairyFactory.get(); // 执行检测 if(testing(d))&#123; return d; &#125; return null; &#125;&#125; 代理模式我们当年建厂的时候没钱，属于小作坊啥也没有，也不规范，那我们现在有钱了，想加强一下生产过程的规范该如何做呢，比如生产前校验车间的温度，生产后校验质量。1234567891011121314151617181920212223242526272829303132// 代理class MilkFactoryProxy implements DairyFactory&#123; // 生产工厂 private MilkFactory milkFactory = new MilkFactory(); public boolean before()&#123; System.out.println("温度检测"); return true; &#125; public boolean after()&#123; System.out.println("质量检测"); return true; &#125; @Override Dairy get()&#123; // 执行检测 if(!before(d))&#123; System.out.println("温度不达标，停止生产"); return null; &#125; Dairy d = milkFactory.get(); // 执行检测 if(after(d))&#123; return d; &#125; return null; &#125;&#125; 晃眼一看感觉装饰者模式和代理模式差不多。。。唯一不同的就是装饰者模式中的源对象是调用者传进去的，而代理模式中的源对象是自己new出来的。 spring 算是把代理模式玩的炉火纯青了吧。。 外观模式 大家知道我们工厂里面不仅有灯，还有风扇，空调等很多东西，我们下班的时候不想一个一个关，怎么办呢，我们直接关总闸： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 开关interface ElectricSwitch&#123; void start(); void stop();&#125;// 电灯class Lamp implements ElectricSwitch&#123; @Override void start()&#123; &#125; @Override void stop()&#123; &#125;&#125;// 风扇class Fan implements ElectricSwitch&#123; @Override void start()&#123; &#125; @Override void stop()&#123; &#125;&#125;// 总闸class MainSwitch implements ElectricSwitch&#123; private Lamp lamp; private Fan fan; public MainSwitch&#123; lamp = new Lamp(); fan = new Fan(); &#125; // 开总闸，风扇和电灯都打开 @Override void start()&#123; lamp.start(); fan.start(); &#125; // 关总闸，风扇和电灯都关闭 @Override void stop()&#123; lamp.stop(); fan.stop(); &#125;&#125; 行为型模式策略模式我们知道生产的牛奶会有很多细菌，而且细菌有很多种杀菌模式，那如果我们某一次生产的细菌是使用的其他杀菌模式改怎么操作呢？123456789101112131415161718192021222324252627282930313233343536 // 消毒柜class DisinfectionBox&#123; private Strategy strategy; public DisinfectionBox(Strategy strategy)&#123; this.strategy = strategy; &#125; // 消毒 void disinfection(Milk milk)&#123; strategy.disinfection(milk); &#125;&#125;// 杀菌方法interface Strategy&#123; void disinfection(Milk milk)&#123; &#125;&#125;// 巴士杀菌法class PasteurizationStrategy implements Strategy&#123; // 巴氏杀菌 void disinfection(Milk milk)&#123;&#125;&#125;class MilkFactory&#123; Milk get()&#123; // 采用巴氏消毒法杀菌 DisinfectionBox disinfectionBox = new DisinfectionBox(new PasteurizationStrategy()); disinfectionBox.disinfection(milk); &#125;&#125; 观察者模式大家知道我们一个厂肯定是有很多采购商的，那么采购商是需要知道我们是否将产品给他们提供出来，这个时候他们就是观察者，而厂就是被观察者。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 我们有个CEOinterface Purchaser&#123; // 生产了牛奶 void milkOk(Milk milk);&#125;// 工厂class MilkFactory&#123; // 观察者 private final List&lt;Purchaser&gt; purchasers = new ArrayList&lt;&gt;(); // 此处需要考虑线程安全问题，如使用： synchronized关键字 public void registerObserver(Purchaser p)&#123; if(ob==null) throw new NullPointerException(); purchasers.add(p) &#125; // 通知采购商取货 public void notifyPurchaser(Milk milk)&#123; for(Purchaser p:purchasers)&#123; p.milk(); &#125; &#125; // 生产牛奶 public Milk get()&#123; Milk milk = new Milk(); // 通知采购商取货 notifyPurchaser(milk); &#125;&#125;// 某个采购商class DummyPurchaser implements Purchaser&#123; @Override void milkOk(Milk milk)&#123; System.out.println("拿到牛奶了！"); &#125;&#125;// 采购商来采购啦class Test&#123; public static void main(String[] args)&#123; // 采购商找到工厂 MilkFactory factory = new MilkFactory(); // 给工厂添加一个采购商 factory.registerObserver(new DummyPurchaser()); // 开始生产 factory.get(); &#125;&#125; 此处可以使用jdk自带的Observer 个人感觉和监听者模式差不多。 模板方法模式待续 迭代子模式待续 责任链模式待续]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用spring security后在页面中无法使用iframe的问题]]></title>
    <url>%2F2019%2F02%2F28%2Fspring-security-iframe%2F</url>
    <content type="text"><![CDATA[这个问题的原因是因为security由于安全、性能等问题禁止了iframe的加载，解决办法如下： 1234567891011protected void configure(HttpSecurity http) throws Exception &#123; // 解决无法使用iframe的问题 http.headers() .frameOptions() // 完全允许加载任何地址的页面 //.disable() // 完全禁止，默认就是这 //.deny() // 只允许加载相同域名下的页面 .sameOrigin();&#125; 扩展阅读： frameOptions里到底是设置了什么东西造成的这种结果呢，这个其实是一个服务器的设置：X-Frame-Options 将这个配置放到我们response header中后，就能实现相关的效果。如： 12345678// 实现了同域名下页面的加载X-Frame-Options: SAMEORIGIN// 实现了禁止加载任何页面X-Frame-Options: DENY// 实现了允许所有页面的加载X-Frame-Options: ALLOW-FROM]]></content>
      <categories>
        <category>spring security</category>
      </categories>
      <tags>
        <tag>spring security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给利用Hexo和GitPages搭建博客绑定个人域名]]></title>
    <url>%2F2019%2F02%2F27%2Fhexo-custom-domain%2F</url>
    <content type="text"><![CDATA[本文档不会提供如何入手域名的相关说明，如果有需要请自行搜索 今天没事上 name.com 入手了个域名： yunwanjia.io。 我寻思着放着也是放着，不如将gitPages的域名绑定一下，毕竟裸奔不怎么好。下面我们就来说一下怎么绑定个人域名。 域名解析配置 域名解析配置每个服务商都不一样，这里我提供 name.com 的配置方式 打开 name.com 的域名配置页面，找到 ==DNS记录== 菜单，点击打开。 找到一个右侧空白记录，增加一个 CNAME 的记录。 如下效果： 类型 主机 回答 TTL CNAME blog.yunwanjia.io smile962464.github.io 300 配置好后可能需要等待几分钟才能有效果，需要看提供商的效率了。 等几分钟后我们访问 blog.yunwanjia.io ,发现是gitpages的404页面，这就代表DNS已经配置好了。接下来我们可以说一下GitHub中的配置。 因为一级域名还有其他用处，所以这里使用二级域名。而且 blog 二级域名还是比较直观。 GitHub 配置这里提供两种配置方式，一种是基于原生GitHub setting中的配置进行配置，一种是基于Hexo的配置。 原生配置打开GitHub的博客仓库，如 smile962464.github.io。 打开 Settings 页面，往下翻找到 GitHub Pages 配置的地方，再往下看，找到 Custom domain 配置处，填入个人博客地址。然后点击保存就好了。 hexo配置到hexo目录的source目录下新建一个叫 ==CNAME== 的文件,注意文件名就叫 CNAME, 不是什么CNAME.txt。 文件建好后在里面填上个人博客地址。然后执行下列命令重新部署: 123$ hexo clean$ hexo g$ hexo d 总结其实就是在博客仓库下面新增一个CNAME的文件，然后在里面填上个人博客的地址。。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用hexo和GitHub Pages搭建个人博客]]></title>
    <url>%2F2019%2F02%2F18%2Fhexo%2F</url>
    <content type="text"><![CDATA[本文用于帮助一点经验也没有的同学搭建一个基于GitHub Pages的无限流量个人blog。为什么用GitHub Pages呢，当然是因为没有钱。 前置GitHub账号全球最大同性交友社区，还不快来玩！ 同学们可以到: GitHub 进行账号注册。注册后新建一个名称叫做 username.github.io 的repository。 举栗子：如果你的github账号是foo，那你就建一个叫做 foo.github.io 的仓库。 等会儿我们博客的内容将会自动发布到该仓库 Node.jsNode.js: 别管我是啥，你看我功能，多棒。 下载安装地址：Node.js 小白建议直接下载LTS版本，即长期支持版，大佬随意。 注意安装的时候需要勾选： Add to PATH 选项 Git下载安装地址：Git 点击后他直接会开始下载，不要方。 注意使用上面的地址下载速度可能非常慢，建议科学上网！ 安装安装Hexo使用以下命令直接进行安装： 1$ npm install -g hexo-cli 生成博客相关文件使用以下命令生成博客相关的文件： 123$ hexo init &lt;folder&gt;$ cd /d &lt;folder&gt;$ npm install &lt;folder&gt; 是指你需要将博客放到哪个位置下去，如：E:/blog。注意不需要&lt;&gt;。 生成出来的相关文件如下说明： 12345678.├── _config.yml ├── package.json ├── scaffolds├── source| ├── _drafts | └── _posts└── themes _config.yml主要的配置文件，同学们记住他，等会儿他要干大事！ package.json恕我直言，此文件小白可忽略 scaffolds模版文件夹, 忽略 source相关资源文件，如发布的文章会放到这里面 themes主题都放在这里，等会儿我们会向这里面放一个叫 NexT 的主题。 配置基础配置打开 _config.yml ,找到以下几项，对照自己的信息进行更改 参数名 参数描述 title 网站标题，如: foo的博客 description 博客描述，seo用。 author 你的大名，如：小猪佩奇 language 使用的语言，注意不要看官网的，要用：zh-CN url 网站url,即上面的:username.github.io 基础配置只需要这么多，其他的很多配置同学们可以自己去学习，反正我是学不会。 安装Next主题使用下列命令行直接安装 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 此处的your-hexo-site即上面使用hexo init &lt;folder&gt; 命令时的folder 启用Next主题打开 hexo 的 _config.yml ,找到theme参数，将其改为next。 1theme: next 设置菜单增加[标签]菜单增加此菜单，需要先增加标签页面，使用以下命令行增加： 12$ cd your-hexo-site$ hexo new page tags 之后hexo会自动在 your-hexo-site/source/ 下生成文件夹：tags，并在tags中生成index.md文件。我们直接用文本编辑器打开此MD文件，并将type改为tags： 1234title: tagsdate: 2019-02-18 21:07:02type: &quot;tags&quot; // 将type改为tagscomments: false 如果生成出来的文件里面没有type，就手动加上。 修改完后，重新进入 NexT 的 _config.yml 文件，找到 menu 的配置处，删除tags的注释： 1234menu: home: / || home #about: /about/ || user tags: /tags/ || tags 增加[分类]菜单增加此菜单，需要先增加分类页面，使用以下命令行增加： 12$ cd your-hexo-site$ hexo new page categories 之后hexo会自动在 your-hexo-site/source/ 下生成文件夹：categories，并在categories中生成index.md文件。我们直接用文本编辑器打开此MD文件，并将type改为categories： 1234title: categoriesdate: 2019-02-18 21:07:02type: &quot;categories&quot; // 将type改为categoriescomments: false 修改完后，重新进入 NexT 的 _config.yml 文件，找到 menu 的配置处，删除categories的注释： 12345menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th 增加disqus支持disqus是国外的评论平台，类似于网易云更贴，需要科学上网。实在是不能科学上网的同学请使用网易云更贴之类的，Next目前支持网易云更贴，来必力等。 首先我们需要去：disqus 注册账号。 然后去创建一个应用，创建方法网上一搜一大把，这里随便给出一个，我就不单独写了。 Hexo添加Disqus评论 应用创建好后，我们得到一个disqus的shortname，如：foo. 接下来我们在 NexT 的 _config.yml 文件中找到disqus配置，将enable改为true,将shortname改为我们在disqus的shortname。 1234disqus: enable: true shortname: foo count: true 同学们打开文章列表后可能会发现评论数展示的为：0 comments,这个可以自己去disqus的网站设置里面改。 增加不蒜子统计不蒜子用于统计全站的访问数，单页面的访问数，很好用。next已经集成了他，只需要在 NexT 的 _config.yml 文件中找到 busuanzi_count 配置，将enable改为true。 12busuanzi_count: enable: true 增加本地搜索本地搜索依赖于： hexo-generator-searchdb,所以我们需要先安装它。 1$ npm install hexo-generator-searchdb --save 安装好后，找到 Hexo 的 _config.yml文件，在该文件中的任意位置加入以下配置： 12345search: path: search.xml field: post format: html limit: 10000 然后在 Next 的 _config.yml文件中找到 local_search 配置，将enable改为true. 12local_search: enable: true 写作使用以下命令创建文章： 1$ hexo new [layout] &lt;title&gt; layout 可以不需要 举例： 1$ hexo new test 调用此命令后，会在 your-hexo-site/source/_posts 下生成test.md文件，这里面就是放我们的文章内容。 我们打开此页面后开头有几个配置，如下： 参数 描述 title 文章标题 keywords seo关键词 tags 标签 categories 分类 如果一个文章有多个tags,可以像下面这种方式： 123tags: - tags1 - tags2 部署标题都说了是基于GitHub Pages，所以我们就把博客部署到github上，那么我们需要一个插件： hexo-deployer-git 1$ npm install hexo-deployer-git --save 安装完成后，在 Hexo 的 _config.yml 文件中找到 deploy 配置，参照以下配置进行修改。 123deploy: type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io 此处的repo就是上面github账户创建的名字叫：username.github.io 的地址 改完以后，通过以下两个命令进行部署： 12hexo cleanhexo deploy 好啦，个人博客部署好啦。接下来就可以使用 username.github.io 来访问你的个人博客拉。 F&amp;Q部署完成后访问404这个有好几个原因造成，请一一对照： 仓库不是public的，请改为public 没有选择仓库默认分支，请到对应仓库的Settings -&gt; GitHub Pages -&gt; source配置下修改默认分支 配置了错误的自定义域名 总结这次也只是最基本的配置了以下，很多深入的都还不会，不过如果只是作为平时记笔记应该也够了。 下次会在详细说以下文章的编写，由于hexo是采用markdown的，不懂markdown语法的可以去研究研究。 ps 其实我也不会。。。 MarkDown 感谢HexoHexo 感谢NexTNexT]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
